package user

import (
	"context"
	"errors"

	"github.com/cantylv/service-happy-birthday/internal/entity"
	"github.com/cantylv/service-happy-birthday/internal/utils/myerrors"
	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/mongo"
)

type Repo interface {
	Create(ctx context.Context, data *entity.User) (string, error)
	Update(ctx context.Context, data *entity.User) (string, error)
	GetByEmail(ctx context.Context, email string) (*entity.User, error)
	GetById(ctx context.Context, id uint32) (*entity.User, error)
}

type RepoLayer struct {
	cl *mongo.Collection
}

// NewRepoLayer
// Returns an instance of repository layer.
func NewRepoLayer(collection *mongo.Collection) RepoLayer {
	return RepoLayer{
		cl: collection,
	}
}

// Create
// Creates new user in database.
func (r *RepoLayer) Create(ctx context.Context, data *entity.User) (string, error) {
	res, err := r.cl.InsertOne(ctx, data)
	if err != nil {
		return "", err
	}
	if res.InsertedID == nil {
		return "", myerrors.ErrInvalidObjectId
	}
	return res.InsertedID.(string), nil
}

// Update
// Updates data about existing user in database.
func (r *RepoLayer) Update(ctx context.Context, data *entity.User) (string, error) {
	filter := bson.M{"id": data.Id}
	res, err := r.cl.ReplaceOne(ctx, filter, data)
	if err != nil {
		return "", err
	}
	if res.MatchedCount == 0 {
		return "", myerrors.ErrUserNotExist
	}
	if res.UpsertedID == nil {
		return "", myerrors.ErrUpdateFailed
	}
	return res.UpsertedID.(string), nil
}

// GetByEmail
// Returns user's struct from document using user email (distinct field).
func (r *RepoLayer) GetByEmail(ctx context.Context, email string) (*entity.User, error) {
	u := entity.User{}
	err := r.cl.FindOne(ctx, bson.M{"email": email}).Decode(&u)
	if err != nil {
		if errors.Is(err, mongo.ErrNoDocuments) {
			return nil, myerrors.ErrUserNotExist
		}
		return nil, err
	}
	return &u, nil
}

// GetById
// Returns user's struct from document using user id (autogenerated field).
func (r *RepoLayer) GetById(ctx context.Context, id uint32) (*entity.User, error) {
	u := entity.User{}
	err := r.cl.FindOne(ctx, bson.M{"id": id}).Decode(&u)
	if err != nil {
		if errors.Is(err, mongo.ErrNoDocuments) {
			return nil, myerrors.ErrUserNotExist
		}
		return nil, err
	}
	return &u, nil
}
